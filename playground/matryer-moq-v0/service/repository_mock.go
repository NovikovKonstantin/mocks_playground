// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"sync"
)

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked Repository
//		mockedRepository := &RepositoryMock{
//			GetFunc: func(keys []string) ([]int64, error) {
//				panic("mock out the Get method")
//			},
//			StoreFunc: func(values []int64) ([]string, error) {
//				panic("mock out the Store method")
//			},
//		}
//
//		// use mockedRepository in code that requires Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(keys []string) ([]int64, error)

	// StoreFunc mocks the Store method.
	StoreFunc func(values []int64) ([]string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Keys is the keys argument value.
			Keys []string
		}
		// Store holds details about calls to the Store method.
		Store []struct {
			// Values is the values argument value.
			Values []int64
		}
	}
	lockGet   sync.RWMutex
	lockStore sync.RWMutex
}

// Get calls GetFunc.
func (mock *RepositoryMock) Get(keys []string) ([]int64, error) {
	if mock.GetFunc == nil {
		panic("RepositoryMock.GetFunc: method is nil but Repository.Get was just called")
	}
	callInfo := struct {
		Keys []string
	}{
		Keys: keys,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(keys)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRepository.GetCalls())
func (mock *RepositoryMock) GetCalls() []struct {
	Keys []string
} {
	var calls []struct {
		Keys []string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Store calls StoreFunc.
func (mock *RepositoryMock) Store(values []int64) ([]string, error) {
	if mock.StoreFunc == nil {
		panic("RepositoryMock.StoreFunc: method is nil but Repository.Store was just called")
	}
	callInfo := struct {
		Values []int64
	}{
		Values: values,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(values)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//
//	len(mockedRepository.StoreCalls())
func (mock *RepositoryMock) StoreCalls() []struct {
	Values []int64
} {
	var calls []struct {
		Values []int64
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}
